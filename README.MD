## NOTE

1. Buat project menjadi go module dengan perintah `go mod init training-golang-goroutine`
2. Menjalankan function secara async adalah dengan menambahkan perintah go di depan function contoh `go RunHelloWorld()`
3. Tapi hati - hati ketika aplikasi program kita sudah selesai, tapi go routine kita belum selesai, bisa jadi function async itu tidak pernah akan menghasilkan sesuatu
4. Channel merupakan tempat komunikasi secara synchronous yang bisa dilakukan oleh GoRoutine (Pengirim-Penerima)
5. Channel hanya bisa menampung 1 data (satu jenis), channel harus di close jika tidak digunakan, jika tidak bisa menyebabkan memory leak
6. Tipe data Channel adalah `chan` untuk membuat channel kita bisa menggunakan perintah `make()` dan kita harus menentukan tipe data inputan `channel := make(chan string)`
7. Deadlock akan terjadi ketika tidak ada yg mengirim dan menerima data
8. Kita bisa menandai channel tersebut sebagai parameter in dan out menggunakan `chan<-` untuk in dan `<-chan` untuk out
9. Buffered Channel merupakan buffer yang bisa digunakan untuk menampung data antrian di channel, agar tidak terjadi proses yang menjadi lambat ketika mengirim atau menerima data di channel
10. Untuk membuat Buffered Channel menggunakan perintah `channel := make(chan string, 3)` 3 sebagai ukuran buffer, `cap(channel)` untuk melihat panjang buffer dan `len(channel)` untuk melihat jumlah data di channel
11. Range Channel, kadang - kadang ada sebuah case dimana sebuah channel dikirim data secara terus menerus, dan kadang tidak jelas kapan channel tersebut akan berhenti menerima data, untuk case ini maka yang bisa kita lakukan adalah menggunakan perulangan range ketika menerima data dari channel
12. Ketika kita ingin mendapatkan data dari semua channel, kita bisa melakukannya dengan Select Channel, dengan hal ini kita bisa memilih data tercepat dari beberapa channel, jika datang secara bersamaan di beberapa channel, maka akan dipilih secara random
13. Dalam select kita bisa menambahkan default, dimana ini akan dieksekusi jika memang di semua channel yang kita select tidak ada datanya. Karena jika kita melakukan select terhadap channel yang tidak ada datanya maka, akan terjadi deadlock sampai channel tersebut mempunyai data
14. Saat kita menggunakan goroutine, dia tidak hanya berjalan secara concurrent, tapi bisa parallel juga, karena bisa ada beberapa thread yang berjalan secara paralel, akan sangat berbahaya ketika kita melakukan manipulasi data variable yang sama oleh beberapa goroutine secara bersamaan (Race Condition)
15. Mutex (Mutual Exclusion) untuk mengatasi masalah Race Condition pada concurenncy/parallel programming di Golang terdapat sebuah struct yang bernama sync.Mutex (bisa digunakan untuk locking-unlocking)
16. RWMutex (Read Write Mutex) terkadang ada kondisi dimana kita ingin melakukan locking tidak hanya pada proses mengubah data, tapi juga membaca data, sebenarnya kita bisa menggunakan Mutex saja, akan tetapi nanti akan rebutan antara proses membaca dan mengubah, di Golang sudah disediakan struct yang bernama RWMutex untuk mengatasi masalah ini
17. Challange dalam membuat aplikasi yang bersifat concurrent atau parallel adalah masalah Deadlock (keadaan dimana goroutine saling menunggu sehingga tidak ada goroutine yang bisa jalan)
18. WaitGroup adalah sebuah fitur di Golang yang bisa digunakan untuk menunggu sebuah proses selesai dilakukan, untuk menandai bahwa ada sebuah proses goroutine kita bisa menggunakan method `Add(int)`, setelah proses goroutine selesai kita bisa menggunakan method `Done()` dan untuk menunggu semua proses selesai kita bisa menggunakan method `Wait()`
19. Once adalah fitur di Golang yang bisa kita gunakan untuk memastikan bahwa sebuah function dieksekusi hanya sekali, jadi berapa banyak pun goroutine yang mengakses, bisa dipastikan bahwa goroutine yang pertama yang bisa mengeksekusi function nya, sehingga goroutine yang lain akan dihiraukan
20. Pool adalah implementasi Design Pattern bernama object pool pattern, sederhananya design pattern Pool ini digunakan untuk menyimpan data, selanjutnya untuk menggunakan datanya, kita bisa mengambil dari Pool dan setelah selesai menggunakan datanya kita bisa mengembalikannya ke Pool, implementasi Pool di Golang sudah aman dari Race Condition